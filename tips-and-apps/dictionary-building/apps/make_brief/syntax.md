# README

*Because having all that without any proper syntax description is useless*

## Commodities

- In AHK brief syntax, I'll refer in "::a::b", as the whole thing being a `Entry`, if there's multiple `Entry`, that makes a `Dictionary`, `a` is the `Brief` of the example `Entry` and `b` is the `Expansion` of the `Entry`.
- Let `Pos(code)` denote every possibilities made from `code`.
- If you have any problem with my program, or... with the way I presented this document, ping me, I'm `awnmp!osu#5349` on Discord.
- If you wreck your Dictionary, that's not my problem, if you are scared on how to use it, read this document, and then ask me directly, I'll be happy to help out if I can :)
(also, I didn't liscenced it, I don't care that much if someone stole it, but please be kind and don't, share it to anyone interested though (and mention it being made by `awnmp`))

## Purpose

Creating multiple `Entry`s to your `Dictionary` faster, in a way that allow to create phrases in MASS.
It's not the first time I do a similar software, but I added a easier-to-deal-with-syntax, function application, and id+conditional requirement for briefs :)

---

## Syntax
It is not whitespace sensitive, feel free to add newlines where you want (as long as it doesn't break up words).

for all a being string:
a => return Entry(brief="", expansion = a)

for all a, b being strings:
`a : b` => return Entry(brief = a, expansion = b)
`a, b, c, ..., z : b` => return {`x : b` | x in ['a', 'b', 'c', ..., 'z']}
if they aren't,
return {`c : b` | c in a and d in b}


`( val )` is used to define the scope of expressions in val (so that `(a : b) c` does not evaluate as `a : b c` (though, for this example, it does the same))
before `(`, you can put a `{}`

{requirement, provide, function, fallback}(block), the number of `,` is important. If `requirement` is empty: there are no requirement. If `provide` is empty, is provides no id, if `function ` is empty, it default to do nothing, if `fallback` is empty, it default to set the block to Entry("", "").
If requirement can't be met, fallback is used instead of function, and the elements in `provide` aren't "provided".
function and fallback take two argument, one for the brief side and the other for the expansion side, and they return a pair of string.

Syntax for `requirement`:
- alphabetic string : return true if it's provided by the ids (not just of this block), otherwise return false.
- + : logical or, `false + false` => `false`, else true.
- * : logical and, `true * true` => `true`, else false. It reads like normal math, `*` have higher priority than `+`
- ! : logical not, `!true` => `false`, `!false` => `true`. It have higher priority than `*`.
- use `[` and `]` to define the scope of your `+`, `*`, `!`, it acts like parethisis (but DON'T use parethesis) 

constants: if you put some characters between two `$`, its value will be called from `const.jl` and embedded in the string. cool if you use the same pattern multiple time :)


`a | b`, `a` or `b`, return every possibilities of a and every possibilities of b, can be used with a and b being expressions/code, not just singular strings.

`a b`, concatenate a and b, it does concatenate both the expansion and the brief part. If a and b have multiple possibilities, concatenate every possibility between a and b. so, return {`a' b'` | a' in a and b' in b}.

`a + b`, actually the same as `a b`, I absolutely don't know what I was thinking when creating it... it looks nice to have it *also* explicitely.

`.... # c # ....`, everything between those two `#` is ignored, you can put comments there.
t
`"..."`, return a string of value `...`, it's used to create words with escaped sequences or whitespace in them. (you can use your regular \ ... as with other strings in other lang), note that the "" aren't actually necessary if your word have no escapped sequences or whitespace. It is one of the only way (the other one is using the `function` part) to get empty strings, useful for when you want to add a necessary thing to write in your `brief` section and not your `expansion one`, example `("you need to type that" : "")`

## misceanous
To use this file, open main.jl with any text-editor of your liking, change `PATH` to the path of your file containing the expression you want to transform into your favorite expansion format.
Change `TO` to where you want the generated file to be written. By default, it'll append to the end of the file, as it's safer to do...
Change `REPLACE` if you're sure you want to delete what was before what has been generated by the generated file. I **HIGHLY** discourage turning it to `true`.

If you want to change the generate syntax, go to `src/SGenerate.jl`, and modify AHK\_FORMAT, as you can see, make it return a string by ""-ing your result, and write `$brief` where you want the brief side to be, and `$exp` where you want the expansion to be.

If you want to create your own function, go to `src/funcs.jl`, **DO NOT** remove `I` (named for `I`dentity). It uses the Julia programming language syntax. See (the documentation)[https://docs.julialang.org/en/v1/base/strings]. If requested, I'll made a blog on how to deal with strings in Julia.
